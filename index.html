<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Step 1 — Catch the Falling (Core)</title>
<style>
  :root{ --bg1:#041022; --bg2:#071a34; --ui:#fff; --accent:#ffd166; }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));font-family:system-ui,Segoe UI,Roboto,Arial;color:var(--ui)}
  .wrap{display:flex;align-items:center;justify-content:center;height:100%;padding:18px;box-sizing:border-box}
  canvas{background:linear-gradient(#072033,#00151f);border-radius:12px;display:block;max-width:100%;height:auto}
  .hud{position:fixed;left:12px;top:12px;font-weight:700;display:flex;gap:10px;align-items:center}
  .pill{background:rgba(255,255,255,0.06);padding:8px 10px;border-radius:999px;border:1px solid rgba(255,255,255,0.04)}
  .controls{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);display:flex;gap:10px}
  .touch{width:80px;height:56px;border-radius:12px;background:rgba(255,255,255,0.05);display:flex;align-items:center;justify-content:center;font-weight:900;user-select:none}
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .menu{pointer-events:auto;background:rgba(0,0,0,0.6);padding:18px;border-radius:12px;text-align:center}
  button{cursor:pointer}
  @media(min-width:900px){ .touch{width:110px;height:70px} }
</style>
</head>
<body>
  <div class="hud">
    <div class="pill" id="scoreP">Score: 0</div>
    <div class="pill" id="livesP">Lives: 3</div>
    <div class="pill" id="levelP">Level: 1</div>
  </div>

  <div class="wrap">
    <canvas id="gameCanvas" width="360" height="640" aria-label="Game"></canvas>
  </div>

  <div class="controls" aria-hidden="false">
    <div class="touch" id="leftBtn">◀</div>
    <div style="width:12px"></div>
    <div class="touch" id="rightBtn">▶</div>
  </div>

  <div class="overlay" id="menuOverlay" style="display:flex">
    <div class="menu" id="menuBox">
      <h2>Catch — Step 1</h2>
      <p>Kontrol: ← → / A D / drag pada kanvas / tombol sentuh. Mulai untuk mengaktifkan game.</p>
      <div style="margin-top:10px">
        <button id="startBtn">Start Game</button>
        <button id="muteBtn" style="margin-left:8px;display:none">Mute</button>
      </div>
      <p style="font-size:12px;opacity:0.85;margin-top:8px">Ini versi dasar. Kita akan lanjut tambah level, logo & musik setelah kamu cek.</p>
    </div>
  </div>

<script>
/* STEP 1: Core mechanics — stable controls + catching + lives
   Paste as index.html and open in browser.
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreP = document.getElementById('scoreP');
const livesP = document.getElementById('livesP');
const levelP = document.getElementById('levelP');
const menuOverlay = document.getElementById('menuOverlay');
const startBtn = document.getElementById('startBtn');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');

const CONFIG = {
  W: 360,
  H: 640,
  bucketW: 84,
  bucketH: 26,
  bucketY: 560,
  bucketSpeed: 420,       // px/sec (keyboard/touch repeat)
  spawnInterval: 0.9,     // sec
  starMinSize: 14,
  starMaxSize: 28,
  starMinSpeed: 120,
  starMaxSpeed: 220
};

// responsive: keep logical canvas size, scale via CSS
function resize() {
  // keep logical resolution
  canvas.width = CONFIG.W;
  canvas.height = CONFIG.H;
  // CSS sizing left to browser (max-width)
}
window.addEventListener('resize', resize);
resize();

/* Game state */
let bucket = { x: CONFIG.W/2, y: CONFIG.bucketY, w: CONFIG.bucketW, h: CONFIG.bucketH };
let stars = [];
let score = 0;
let lives = 3;   // jumlah nyawa awal
let level = 1;   // level awal
let ballSpeed = 2; // kecepatan bola awal
let elapsedSpawn = 0;
let lastTime = 0;
let keys = {};
let leftTouch = false, rightTouch = false;
let pointerActive = false, pointerX = null;
let gameState = 'menu'; // menu | playing | over

/* Input: keyboard */
window.addEventListener('keydown', e => {
  const k = e.key;
  if (k === 'ArrowLeft' || k === 'a' || k === 'A') keys.left = true;
  if (k === 'ArrowRight' || k === 'd' || k === 'D') keys.right = true;
  if (k === ' ' && gameState !== 'playing') startGame();
});
window.addEventListener('keyup', e => {
  const k = e.key;
  if (k === 'ArrowLeft' || k === 'a' || k === 'A') keys.left = false;
  if (k === 'ArrowRight' || k === 'd' || k === 'D') keys.right = false;
});

/* Touch buttons */
leftBtn.addEventListener('pointerdown', e => { leftTouch = true; leftBtn.setPointerCapture(e.pointerId); leftBtn.style.transform='translateY(2px)'; });
leftBtn.addEventListener('pointerup', e => { leftTouch = false; leftBtn.style.transform=''; });
leftBtn.addEventListener('pointercancel', e => { leftTouch = false; leftBtn.style.transform=''; });
rightBtn.addEventListener('pointerdown', e => { rightTouch = true; rightBtn.setPointerCapture(e.pointerId); rightBtn.style.transform='translateY(2px)'; });
rightBtn.addEventListener('pointerup', e => { rightTouch = false; rightBtn.style.transform=''; });
rightBtn.addEventListener('pointercancel', e => { rightTouch = false; rightBtn.style.transform=''; });

/* Pointer drag on canvas */
canvas.addEventListener('pointerdown', e => {
  pointerActive = true;
  const r = canvas.getBoundingClientRect();
  pointerX = (e.clientX - r.left) * (canvas.width / r.width);
});
canvas.addEventListener('pointermove', e => {
  if (!pointerActive) return;
  const r = canvas.getBoundingClientRect();
  pointerX = (e.clientX - r.left) * (canvas.width / r.width);
});
window.addEventListener('pointerup', e => { pointerActive = false; pointerX = null; });

/* Spawn factory */
function spawnStar() {
  const size = rand(CONFIG.starMinSize, CONFIG.starMaxSize);
  const x = rand(size/2, CONFIG.W - size/2);
  const speed = rand(CONFIG.starMinSpeed, CONFIG.starMaxSpeed);
  stars.push({ x, y: -size, r: size/2, speed });
}

/* Helpers */
function rand(a,b){ return a + Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* Start / Restart */
startBtn.addEventListener('click', () => {
  if (gameState !== 'playing') startGame();
});

function startGame(){
  score = 0;
  lives = 3;
  level = 1;
  stars = [];
  elapsedSpawn = 0;
  lastTime = performance.now();
  bucket.x = CONFIG.W/2;
  gameState = 'playing';
  menuOverlay.style.display = 'none';
  requestAnimationFrame(loop);
}

function endGame(){
  gameState = 'over';
  menuOverlay.style.display = 'flex';
  document.getElementById('menuBox').querySelector('h2').textContent = 'Game Over';
  document.getElementById('menuBox').querySelector('p').textContent = 'Skor: ' + Math.floor(score) + ' — Tekan Start untuk main lagi.';
  document.getElementById('startBtn').textContent = 'Restart';
}

/* Main loop */
function loop(ts){
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;
  if (gameState === 'playing'){
    update(dt);
    render();
    requestAnimationFrame(loop);
  }
}

/* Update */
function update(dt){
  // movement
  let move = 0;
  if (keys.left) move -= 1;
  if (keys.right) move += 1;
  if (leftTouch) move -= 1;
  if (rightTouch) move += 1;

  if (pointerActive && pointerX !== null){
    // smooth follow pointer
    const diff = pointerX - bucket.x;
    bucket.x += diff * clamp(10*dt, 0, 1);
  } else {
    bucket.x += move * CONFIG.bucketSpeed * dt;
  }
  bucket.x = clamp(bucket.x, bucket.w/2, CONFIG.W - bucket.w/2);

  // spawn
  elapsedSpawn += dt;
  if (elapsedSpawn >= CONFIG.spawnInterval) {
    spawnStar();
    elapsedSpawn = 0;
  }

  // update stars (iterate backwards)
  for (let i = stars.length - 1; i >= 0; i--){
    const s = stars[i];
    s.y += s.speed * dt;
    // collision: bucket rect centered at bucket.x
    const bx = bucket.x - bucket.w/2;
    const by = bucket.y - bucket.h/2;
    if (rectCircleCollision(bx, by, bucket.w, bucket.h, s.x, s.y, s.r)){
      // caught
      stars.splice(i,1);
      score += Math.max(5, Math.round(s.r)); // increase score
      // spawn one more to keep flow
      spawnStar();
      updateHUD();
      continue;
    }
    // missed
    if (s.y - s.r > CONFIG.H){
      stars.splice(i,1);
      lives -= 1;
      updateHUD();
      spawnStar();
      if (lives <= 0){ endGame(); return; }
    }
  }
}

/* HUD */
function updateHUD(){
  scoreP.textContent = 'Score: ' + Math.floor(score);
  livesP.textContent = 'Lives: ' + lives;
  levelP.textContent = 'Level: ' + level;
}

/* Render */
function render(){
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // background stars
  ctx.save();
  const gg = ctx.createLinearGradient(0,0,0,canvas.height);
  gg.addColorStop(0,'rgba(255,255,255,0.02)');
  gg.addColorStop(1,'rgba(255,255,255,0.00)');
  ctx.fillStyle = gg;
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.restore();

  // draw bucket (simple triangle+rect)
  drawBucket();

  // draw stars
  ctx.fillStyle = '#ffd166';
  for (const s of stars){
    ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fill();
    // small crater
    ctx.fillStyle = 'rgba(0,0,0,0.08)'; ctx.beginPath(); ctx.arc(s.x - s.r*0.2, s.y - s.r*0.15, s.r*0.28, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ffd166';
  }
}

/* draw bucket helper */
function drawBucket(){
  ctx.save();
  ctx.translate(bucket.x, bucket.y);
  // body
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.moveTo(0, -bucket.h/2);
  ctx.lineTo(bucket.w/2, bucket.h/2);
  ctx.lineTo(-bucket.w/2, bucket.h/2);
  ctx.closePath();
  ctx.fill();
  // rim
  ctx.fillStyle = '#ffb84a';
  ctx.fillRect(-bucket.w/2, -bucket.h/2 - 6, bucket.w, 8);
  ctx.restore();
}

/* rect-circle collision */
function rectCircleCollision(rx,ry,rw,rh, cx,cy,cr){
  const closestX = clamp(cx, rx, rx+rw);
  const closestY = clamp(cy, ry, ry+rh);
  const dx = cx - closestX;
  const dy = cy - closestY;
  return (dx*dx + dy*dy) <= (cr*cr);
}

/* init HUD */
updateHUD();
/* prevent scrolling while interacting on touch */
['touchstart','touchmove','touchend','touchcancel'].forEach(ev=>{
  window.addEventListener(ev, e=>{
    if (e.target === canvas || e.target === leftBtn || e.target === rightBtn) e.preventDefault();
  }, {passive:false});
});

</script>
</body>
</html>
