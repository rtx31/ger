<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Step 1 — Catch (Core)</title>
<style>
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#041022,#071a34);color:#fff}
  .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:18px;box-sizing:border-box}
  canvas{background:linear-gradient(180deg,#072033,#00151f);border-radius:12px;max-width:100%;height:auto;display:block}
  .hud{position:fixed;left:12px;top:12px;display:flex;gap:8px;font-weight:700}
  .pill{background:rgba(255,255,255,0.06);padding:8px 10px;border-radius:999px;border:1px solid rgba(255,255,255,0.04)}
  .controls{position:fixed;bottom:18px;left:50%;transform:translateX(-50%);display:flex;gap:12px}
  .touch{width:78px;height:56px;border-radius:12px;background:rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;font-weight:900;user-select:none}
  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .menu{pointer-events:auto;background:rgba(0,0,0,0.6);padding:18px;border-radius:12px;text-align:center}
  button{cursor:pointer;padding:8px 12px;border-radius:10px;border:none;background:#ffd166;font-weight:800}
  @media(min-width:900px){ .touch{width:110px;height:70px} }
</style>
</head>
<body>
  <div class="hud">
    <div class="pill" id="scoreP">Score: 0</div>
    <div class="pill" id="livesP">Lives: 3</div>
    <div class="pill" id="levelP" style="display:none">Level: 1</div>
  </div>

  <div class="wrap">
    <canvas id="gameCanvas" width="360" height="640" aria-label="Game canvas"></canvas>
  </div>

  <div class="controls" aria-hidden="false">
    <div class="touch" id="leftBtn">◀</div>
    <div class="touch" id="rightBtn">▶</div>
  </div>

  <div class="overlay" id="menuOverlay">
    <div class="menu" id="menuBox">
      <h2>Catch — Step 1</h2>
      <p>Kontrol: ← → / A D / drag pada kanvas / tombol sentuh. Klik Start untuk mulai.</p>
      <div style="margin-top:10px">
        <button id="startBtn">Start Game</button>
      </div>
      <p style="font-size:12px;opacity:0.85;margin-top:8px">Versi dasar — setelah kamu cek kita lanjut ke leveling, logo & audio.</p>
    </div>
  </div>

<script>
/* STEP 1: Core mechanics */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreP = document.getElementById('scoreP');
const livesP = document.getElementById('livesP');
const levelP = document.getElementById('levelP');
const menuOverlay = document.getElementById('menuOverlay');
const startBtn = document.getElementById('startBtn');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');

const CONFIG = {
  W: 360, H: 640,
  bucketW: 84, bucketH: 26, bucketY: 560,
  bucketSpeed: 420,
  spawnInterval: 0.9,
  objMinSize: 14, objMaxSize: 28,
  objMinSpeed: 120, objMaxSpeed: 220
};

function resize(){ canvas.width = CONFIG.W; canvas.height = CONFIG.H; }
window.addEventListener('resize', resize);
resize();

/* state */
let bucket = { x: CONFIG.W/2, y: CONFIG.bucketY, w: CONFIG.bucketW, h: CONFIG.bucketH };
let objects = [];
let score = 0;
let lives = 3;
let level = 1;
let elapsedSpawn = 0;
let lastTime = 0;
let keys = {};
let leftTouch = false, rightTouch = false;
let pointerActive = false, pointerX = null;
let gameState = 'menu'; // menu | playing | over

/* input */
window.addEventListener('keydown', e=>{
  const k = e.key;
  if (k === 'ArrowLeft' || k === 'a' || k === 'A') keys.left = true;
  if (k === 'ArrowRight' || k === 'd' || k === 'D') keys.right = true;
  if (k === ' ' && gameState !== 'playing') startGame();
});
window.addEventListener('keyup', e=>{
  const k = e.key;
  if (k === 'ArrowLeft' || k === 'a' || k === 'A') keys.left = false;
  if (k === 'ArrowRight' || k === 'd' || k === 'D') keys.right = false;
});

/* touch buttons */
leftBtn.addEventListener('pointerdown', e=>{ leftTouch=true; leftBtn.setPointerCapture(e.pointerId); leftBtn.style.transform='translateY(2px)'; });
leftBtn.addEventListener('pointerup', e=>{ leftTouch=false; leftBtn.style.transform=''; });
leftBtn.addEventListener('pointercancel', e=>{ leftTouch=false; leftBtn.style.transform=''; });
rightBtn.addEventListener('pointerdown', e=>{ rightTouch=true; rightBtn.setPointerCapture(e.pointerId); rightBtn.style.transform='translateY(2px)'; });
rightBtn.addEventListener('pointerup', e=>{ rightTouch=false; rightBtn.style.transform=''; });
rightBtn.addEventListener('pointercancel', e=>{ rightTouch=false; rightBtn.style.transform=''; });

/* pointer drag */
canvas.addEventListener('pointerdown', e=>{
  pointerActive = true;
  const r = canvas.getBoundingClientRect();
  pointerX = (e.clientX - r.left) * (canvas.width / r.width);
});
canvas.addEventListener('pointermove', e=>{
  if (!pointerActive) return;
  const r = canvas.getBoundingClientRect();
  pointerX = (e.clientX - r.left) * (canvas.width / r.width);
});
window.addEventListener('pointerup', ()=>{ pointerActive = false; pointerX = null; });

/* spawn object */
function rand(a,b){ return a + Math.random()*(b-a); }
function spawnObject(){
  const size = Math.round(rand(CONFIG.objMinSize, CONFIG.objMaxSize));
  const x = rand(size/2, CONFIG.W - size/2);
  const speed = rand(CONFIG.objMinSpeed, CONFIG.objMaxSpeed);
  objects.push({ x, y: -size, r: size/2, speed });
}

/* collision rect-circle */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rectCircleCollision(rx,ry,rw,rh, cx,cy,cr){
  const closestX = clamp(cx, rx, rx+rw);
  const closestY = clamp(cy, ry, ry+rh);
  const dx = cx - closestX; const dy = cy - closestY;
  return (dx*dx + dy*dy) <= (cr*cr);
}

/* start / end */
startBtn.addEventListener('click', ()=>{ if (gameState !== 'playing') startGame(); });
function startGame(){
  score = 0; lives = 3; level = 1; objects = []; elapsedSpawn = 0;
  bucket.x = CONFIG.W/2; lastTime = performance.now(); gameState = 'playing';
  menuOverlay.style.display = 'none';
  requestAnimationFrame(loop);
}
function endGame(){
  gameState = 'over';
  menuOverlay.style.display = 'flex';
  document.getElementById('menuBox').querySelector('h2').textContent = 'Game Over';
  document.getElementById('menuBox').querySelector('p').textContent = 'Skor: ' + Math.floor(score) + ' — tekan Start untuk ulang.';
  document.getElementById('startBtn').textContent = 'Restart';
}

/* loop */
function loop(ts){
  const dt = Math.min((ts - lastTime)/1000, 0.05);
  lastTime = ts;
  if (gameState === 'playing'){ update(dt); render(); requestAnimationFrame(loop); }
}

/* update */
function update(dt){
  // movement
  let move = 0;
  if (keys.left) move -= 1;
  if (keys.right) move += 1;
  if (leftTouch) move -= 1;
  if (rightTouch) move += 1;

  if (pointerActive && pointerX !== null){
    const diff = pointerX - bucket.x;
    bucket.x += diff * clamp(10*dt, 0, 1);
  } else {
    bucket.x += move * CONFIG.bucketSpeed * dt;
  }
  // bucket center clamp
  bucket.x = clamp(bucket.x, bucket.w/2, CONFIG.W - bucket.w/2);

  // spawn
  elapsedSpawn += dt;
  if (elapsedSpawn >= CONFIG.spawnInterval){ spawnObject(); elapsedSpawn = 0; }

  // update objects (backwards)
  for (let i = objects.length - 1; i >= 0; i--){
    const o = objects[i];
    o.y += o.speed * dt;
    const bx = bucket.x - bucket.w/2;
    const by = bucket.y - bucket.h/2;
    if (rectCircleCollision(bx, by, bucket.w, bucket.h, o.x, o.y, o.r)){
      // caught
      objects.splice(i,1);
      score += Math.max(1, Math.round(o.r));
      spawnObject(); // keep flow
      updateHUD();
      continue;
    }
    // missed
    if (o.y - o.r > CONFIG.H){
      objects.splice(i,1);
      lives -= 1;
      spawnObject();
      updateHUD();
      if (lives <= 0){ endGame(); return; }
    }
  }
}

/* HUD & render */
function updateHUD(){ scoreP.textContent = 'Score: ' + Math.floor(score); livesP.textContent = 'Lives: ' + lives; }
function drawBucket(){
  ctx.save();
  ctx.translate(bucket.x, bucket.y);
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.moveTo(0, -bucket.h/2);
  ctx.lineTo(bucket.w/2, bucket.h/2);
  ctx.lineTo(-bucket.w/2, bucket.h/2);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#ffb84a';
  ctx.fillRect(-bucket.w/2, -bucket.h/2 - 6, bucket.w, 8);
  ctx.restore();
}
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background stars
  const gg = ctx.createLinearGradient(0,0,0,canvas.height);
  gg.addColorStop(0,'rgba(255,255,255,0.02)'); gg.addColorStop(1,'rgba(255,255,255,0)');
  ctx.fillStyle = gg; ctx.fillRect(0,0,canvas.width,canvas.height);

  // bucket
  drawBucket();

  // objects
  ctx.fillStyle = '#ffd166';
  for (const o of objects){
    ctx.beginPath(); ctx.arc(o.x, o.y, o.r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = 'rgba(0,0,0,0.08)'; ctx.beginPath(); ctx.arc(o.x - o.r*0.2, o.y - o.r*0.15, o.r*0.28, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ffd166';
  }

  // HUD small text
  ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.font = '14px system-ui, Arial'; ctx.fillText('Score: ' + Math.floor(score), 12, 22);
  ctx.fillText('Lives: ' + lives, 12, 42);
}

/* init */
updateHUD();
/* prevent scrolling when interacting with game on touch */
['touchstart','touchmove','touchend','touchcancel'].forEach(ev=>{
  window.addEventListener(ev, e=>{
    if (e.target === canvas || e.target === leftBtn || e.target === rightBtn) e.preventDefault();
  }, {passive:false});
});
</script>
</body>
</html>
